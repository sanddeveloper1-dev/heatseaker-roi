/**
 * HeatSeaker Template - Commercial Software
 * Copyright (c) 2024 Paul Stortini
 * Software Development & Maintenance by Alexander Meyer
 * 
 * ZERO LIABILITY NOTICE: Service provider assumes no liability for betting operations.
 * Client bears 100% responsibility for all business outcomes.
 * 
 * This software is provided "AS IS" without warranty.
 * For complete terms, see SERVICE_AGREEMENT.md
 * 
 * ROI Totals Extraction Script
 * 
 * Extracts totals from all date-named TEE sheets (generated by 06-ROIHistorical.js)
 * and appends them to the TOTALS sheet.
 * 
 * Features:
 * - Loops through all sheets named as dates (MM/dd/yy format)
 * - Extracts BET, COLLECT, BETS, and WINS from specified cells
 * - Appends to TOTALS sheet starting at row 11
 * - Skips duplicates (dates already in TOTALS)
 * - Handles execution time limits for large datasets
 */

const RoiTotalsConfig = {
	TOTALS_SHEET_NAME: Config?.TAB_TOTALS || 'TOTALS',
	TEE_SHEET_NAME: Config?.TAB_TEE || 'TEE',
	TOTALS_START_ROW: 11,
	TIMEZONE: Config?.DB_TRACKING?.TIMEZONE || 'America/New_York',

	// Cell references in TEE sheets for totals
	TEE_CELL_BET: 'BI2',      // BET
	TEE_CELL_COLLECT: 'BJ2',  // COLLECT
	TEE_CELL_BETS: 'BM2',     // BETS
	TEE_CELL_WINS: 'BN2',     // WINS
	TEE_CELL_PROCESSED: 'BR1', // Flag to mark sheet as processed (TRUE/FALSE)

	// TOTALS sheet column indices (0-based)
	TOTALS_COL_DATE: 0,       // Column A: DATES
	TOTALS_COL_BET: 1,        // Column B: BET
	TOTALS_COL_COLLECT: 2,    // Column C: COLLECT
	TOTALS_COL_BETS: 3,       // Column D: BETS
	TOTALS_COL_WINS: 4,       // Column E: WINS

	// Performance settings
	MAX_EXECUTION_TIME_MS: 5.5 * 60 * 1000, // 5.5 minutes (leave buffer before 6 min limit)
};

/**
 * Main entry point - extracts totals from all date-named TEE sheets and appends to TOTALS
 * @returns {Object} Summary of processing
 */
function extractRoiTotals() {
	const startTime = Date.now();
	console.log('üöÄ Starting ROI Totals extraction...');

	try {
		const ss = SpreadsheetApp.getActiveSpreadsheet();
		const totalsSheet = getSheetOrThrow_(ss, RoiTotalsConfig.TOTALS_SHEET_NAME);

		// Get all sheets and filter for date-named sheets (MM/dd/yy format)
		const allSheets = ss.getSheets();
		const dateSheets = filterDateSheets_(allSheets);

		console.log(`üìä Found ${dateSheets.length} date-named sheets`);

		if (dateSheets.length === 0) {
			console.log('‚ö†Ô∏è No date-named sheets found');
			return { success: false, error: 'No date-named sheets found' };
		}

		// Extract and prepare totals data
		const summary = {
			totalSheets: dateSheets.length,
			processedSheets: 0,
			skippedSheets: 0,
			appendedRows: 0,
			errors: [],
		};

		for (let i = 0; i < dateSheets.length; i++) {
			// Check execution time limit
			const elapsed = Date.now() - startTime;
			if (elapsed >= RoiTotalsConfig.MAX_EXECUTION_TIME_MS) {
				console.log(`‚è±Ô∏è Time limit approaching. Processed ${summary.processedSheets} sheets. Stopping.`);
				summary.message = 'Time limit reached. Run extractRoiTotals() again to continue.';
				break;
			}

			const sheet = dateSheets[i];
			const sheetName = sheet.getName();

			// Double-check BR1 in case it was set while processing
			if (isSheetProcessed_(sheet)) {
				summary.skippedSheets++;
				console.log(`‚è≠Ô∏è Skipping ${sheetName} - already processed (BR1 is TRUE)`);
				continue;
			}

			try {
				// Extract totals from this sheet
				const totals = extractTotalsFromSheet_(sheet);

				if (totals) {
					// Append to TOTALS sheet immediately
					const rowAppended = appendTotalsToSheet_(totalsSheet, [{
						date: sheetName,
						bet: totals.bet,
						collect: totals.collect,
						bets: totals.bets,
						wins: totals.wins,
					}]);

					// Mark sheet as processed immediately (set BR1 to TRUE)
					markSheetAsProcessed_(sheet);

					summary.processedSheets++;
					summary.appendedRows += rowAppended;
					console.log(`‚úÖ Processed ${sheetName}: BET=${totals.bet}, COLLECT=${totals.collect}, BETS=${totals.bets}, WINS=${totals.wins} (marked BR1 as TRUE)`);
				} else {
					summary.skippedSheets++;
					console.log(`‚ö†Ô∏è Could not extract totals from ${sheetName} - missing or invalid data`);
				}
			} catch (error) {
				summary.errors.push({ sheet: sheetName, error: error.message });
				console.error(`‚ùå Error processing ${sheetName}:`, error);
				// Don't mark as processed if there was an error
			}
		}

		if (summary.processedSheets === summary.totalSheets - summary.skippedSheets) {
			summary.message = 'All sheets processed successfully!';
		}

		console.log(`‚úÖ Processing complete. Summary:`, summary);
		return summary;

	} catch (error) {
		console.error('‚ùå Fatal error in extractRoiTotals:', error);
		return { success: false, error: error.message };
	}
}

// -----------------------------
// Helper functions
// -----------------------------

/**
 * Filter sheets to only include date-named sheets (MM/dd/yy format)
 * @param {Array<GoogleAppsScript.Spreadsheet.Sheet>} sheets - All sheets in spreadsheet
 * @returns {Array<GoogleAppsScript.Spreadsheet.Sheet>} Array of date-named sheets
 */
function filterDateSheets_(sheets) {
	const dateSheets = [];
	const datePattern = /^\d{2}\/\d{2}\/\d{2}$/; // MM/dd/yy format

	sheets.forEach(sheet => {
		const sheetName = sheet.getName();

		// Skip TOTALS, TEE, DATABASE, UTILITY, TEMPLATE, etc.
		const skipNames = [
			RoiTotalsConfig.TOTALS_SHEET_NAME,
			RoiTotalsConfig.TEE_SHEET_NAME,
			'DATABASE',
			'UTILITY',
			'TEMPLATE',
			'RATIO TEMPLATE',
		];

		if (skipNames.includes(sheetName.toUpperCase())) {
			return;
		}

		// Check if sheet name matches date pattern (MM/dd/yy)
		if (datePattern.test(sheetName)) {
			// Skip if already processed (BR1 is TRUE)
			if (!isSheetProcessed_(sheet)) {
				dateSheets.push(sheet);
			}
		}
	});

	// Sort by date for consistent processing order
	dateSheets.sort((a, b) => {
		const dateA = parseDateFromSheetName_(a.getName());
		const dateB = parseDateFromSheetName_(b.getName());
		if (!dateA || !dateB) return 0;
		return dateA - dateB; // Sort chronologically
	});

	return dateSheets;
}

/**
 * Parse date from sheet name (MM/dd/yy format)
 * @param {string} sheetName - Sheet name in MM/dd/yy format
 * @returns {Date|null} Parsed date or null if invalid
 */
function parseDateFromSheetName_(sheetName) {
	try {
		const parts = sheetName.split('/');
		if (parts.length !== 3) return null;

		const month = parseInt(parts[0], 10) - 1; // JS months are 0-indexed
		const day = parseInt(parts[1], 10);
		let year = parseInt(parts[2], 10);

		// Convert 2-digit year to 4-digit (assume 2000-2099 range)
		if (year < 100) {
			year += 2000;
		}

		const date = new Date(year, month, day);

		// Validate date
		if (date.getMonth() !== month || date.getDate() !== day || date.getFullYear() !== year) {
			return null;
		}

		return date;
	} catch (error) {
		return null;
	}
}

/**
 * Check if a sheet has been processed (BR1 is TRUE)
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet - Sheet to check
 * @returns {boolean} True if sheet is already processed
 */
function isSheetProcessed_(sheet) {
	try {
		const processedFlag = sheet.getRange(RoiTotalsConfig.TEE_CELL_PROCESSED).getValue();
		return processedFlag === true || processedFlag === 'TRUE' || processedFlag === 'True';
	} catch (error) {
		// If cell doesn't exist or error, assume not processed
		return false;
	}
}

/**
 * Mark a sheet as processed by setting BR1 to TRUE
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet - Sheet to mark as processed
 */
function markSheetAsProcessed_(sheet) {
	try {
		const processedCell = sheet.getRange(RoiTotalsConfig.TEE_CELL_PROCESSED);
		processedCell.setValue(true);
	} catch (error) {
		console.error(`Error marking sheet ${sheet.getName()} as processed:`, error);
	}
}

/**
 * Extract totals from a TEE sheet
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet - TEE sheet to extract from
 * @returns {Object|null} Totals object or null if extraction failed
 */
function extractTotalsFromSheet_(sheet) {
	try {
		// Extract values from specified cells
		const bet = sheet.getRange(RoiTotalsConfig.TEE_CELL_BET).getValue();
		const collect = sheet.getRange(RoiTotalsConfig.TEE_CELL_COLLECT).getValue();
		const bets = sheet.getRange(RoiTotalsConfig.TEE_CELL_BETS).getValue();
		const wins = sheet.getRange(RoiTotalsConfig.TEE_CELL_WINS).getValue();

		// Validate that we got values (not empty or error)
		// Allow 0 values but not null/undefined/empty
		if (bet === null || bet === undefined || bet === '') {
			return null;
		}
		if (collect === null || collect === undefined || collect === '') {
			return null;
		}
		if (bets === null || bets === undefined || bets === '') {
			return null;
		}
		if (wins === null || wins === undefined || wins === '') {
			return null;
		}

		return {
			bet: bet,
			collect: collect,
			bets: bets,
			wins: wins,
		};
	} catch (error) {
		console.error(`Error extracting totals from sheet ${sheet.getName()}:`, error);
		return null;
	}
}

/**
 * Append totals to TOTALS sheet starting at the next available row
 * @param {GoogleAppsScript.Spreadsheet.Sheet} totalsSheet - TOTALS sheet
 * @param {Array<Object>} totalsData - Array of totals objects to append
 * @returns {number} Number of rows appended
 */
function appendTotalsToSheet_(totalsSheet, totalsData) {
	if (totalsData.length === 0) {
		return 0;
	}

	// Find next row to append (either after last row or at TOTALS_START_ROW)
	const lastRow = totalsSheet.getLastRow();
	const appendStartRow = Math.max(lastRow + 1, RoiTotalsConfig.TOTALS_START_ROW);

	// Build rows array: [DATE, BET, COLLECT, BETS, WINS]
	const rows = totalsData.map(totals => [
		totals.date,        // Column A: DATES
		totals.bet,         // Column B: BET
		totals.collect,     // Column C: COLLECT
		totals.bets,        // Column D: BETS
		totals.wins,        // Column E: WINS
	]);

	// Append all rows in batch
	totalsSheet.getRange(appendStartRow, 1, rows.length, 5).setValues(rows);

	return rows.length;
}

/**
 * Get sheet by name or throw error
 * @param {GoogleAppsScript.Spreadsheet.Spreadsheet} ss - Spreadsheet
 * @param {string} name - Sheet name
 * @returns {GoogleAppsScript.Spreadsheet.Sheet} Sheet object
 */
function getSheetOrThrow_(ss, name) {
	const sheet = ss.getSheetByName(name);
	if (!sheet) {
		throw new Error(`Sheet "${name}" not found.`);
	}
	return sheet;
}

